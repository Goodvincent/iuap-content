# 事务控制与连接池

## 4.1.1 事务简介
在持久化操作时，如果是更新操作或者涉及到多表操作，一般需要进行事务控制来保证数据的完整性和一致性。控制事务的方式有多种，可以采取编程式事务，或者配置型事务。在iUAP持久层框架的基础上，推荐使用Spring的事务控制，采用注解配置的方式进行事务控制。
IUAP平台提供的持久化方式有多种，如果单独使用Spring jdbc或者Mybatis，可以采用DataSourceTransactionManager进行事务管理，如果和Spring Data Jpa混合使用，需要配置为JpaTransactionManager，建议业务开发前期进行选型，尽量避免持久层的混合使用。
## 4.1.2 事务传播机制
Spring事务的几种传播特性如下：

	PROPAGATION_REQUIRED: 
    如果存在一个事务，则支持当前事务。如果没有事务则开启。
	PROPAGATION_SUPPORTS: 
    如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行。
	PROPAGATION_MANDATORY: 
    如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。
	PROPAGATION_REQUIRES_NEW: 
    总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。
	PROPAGATION_NOT_SUPPORTED: 
    总是非事务地执行，并挂起任何存在的事务。
	PROPAGATION_NEVER: 
    总是非事务地执行，如果存在一个活动事务，则抛出异常。
	PROPAGATION_NESTED：
    如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务, 则按TransactionDefinition.PROPAGATION_REQUIRED 属性执行。
业务开发Service类时候，可以在方法上指定事务的传播机制，按照业务需求配置具体的属性，默认配置为PROPAGATION_REQUIRED，也是最常用。
## 4.1.3 事务隔离级别
	在多个事务并发执行操作数据库时，需要考虑事务的隔离级别。 数据库事务的隔离级别有4个，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。
概念定义：
1）脏读: 
    指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据， 那么另外一个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。 
2）不可重复读: 
    指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。     
3）幻读: 
指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。
数据库的不同的事务隔离级别可能出现的脏读、不可重复读和幻读的现象也不同，出现的情况如下：√: 可能出现    ×: 不会出现
